#!/usr/bin/env python
"""
This program uses the QR decomposition method to calculate the eigenvalues of
a matrix.

The library provided by this module can used for any operation on matrix.

By convention, the following code will be written in English.
"""

__author__    = "Lysandre Macke"
__credits__   = ["Lysandre Macke"]
__version__   = "0.1.0"
__email__     = "lysandre.macke@edu.univ-eiffel.fr"

import sys
import math

### Code

def scalar(u, v):
    """
    Returns the scalar product of two vectors (list of int) u.v
    """
    if len(u) != len(v):
        sys.exit("Error : vectors must be of the same length to apply scalar product"\
                 + " (first vector is of length " + str(len(u))\
                 + " and second is of length " + str(len(v)) + ").")

    result = 0;
    for i in range (len(u)):
        result += u[i] * v[i]

    return result


def orthogonalProjection(u, v):
    """
    Returns the orthogonal projection of vector (list of int) v on the
    vectorial line generated by the vector u.
    This operation corresponds to the following writing :
    proj_u(v)
    """
    result = Matrix("", u.copy())

    result.multiplyByFactor(scalar(v, u)/scalar(u, u))

    return result.coeffs


def addVectors(u, v):
    """
    Returns the sum of vector u and v (which are represented by lists).
    """
    if len(u) != len(v):
        sys.exit("Error : vectors must be of the same length to be summed together"\
                 + " (first vector is of length " + str(len(u))\
                 + " and second is of length " + str(len(v)) + ").")

    result = []
    for i in range (len(u)):
        result.append(u[i] + v[i])
    return result


def substractVectors(u, v):
    """
    Returns the sustraction of vector u and v (which are represented by lists).
    """
    if len(u) != len(v):
        sys.exit("Error : vectors must be of the same length to be summed together"\
                 + " (first vector is of length " + str(len(u))\
                 + " and second is of length " + str(len(v)) + ").")

    result = []
    for i in range (len(u)):
        result.append(u[i] - v[i])
    return result


def normOf(u):
    """
    Returns the norm of a given vector u (which must be a list).
    """
    sum = 0
    for i in range (len(u)):
        sum += u[i]**2
    return math.sqrt(sum)


def generateMatrixWithCols(name, colList):
    """
    Returns a Matrix object of given name from a column list.
    """
    coeffs = []

    for i in range (len(colList[0])):
        line = []
        for j in range (len(colList)):
            line.append(colList[j][i])
        coeffs.append(line)

    return Matrix(name, coeffs)


def multiplyMatrix(A, B, name = 0):
    """
    Returns the product AB (where A and B are Matrix objects).
    """
    if A.nbCols() != B.nbLines():
        sys.exit("Error : the given matrix " + A.name + " and " + B.name
                 + " cannot be multiplicated together.")

    #autogenerating a name if the name isn't specified
    if not name:
        name = A.name + B.name

    if A.nbLines() == 1:
        B.coeffs = B.getCol(1)
        result = Matrix(name, [scalar(A.coeffs, B.coeffs)])

    else:
        result = Matrix(name, [])
        for j in range (A.nbLines()):
            line = []
            for i in range (B.nbCols()):
                coeff = 0;
                for k in range (A.nbCols()):
                    coeff += A.getCoeff(k + 1, j + 1) * B.getCoeff(i + 1, k + 1)
                line.append(coeff)
            result.coeffs.append(line)

    return result


def findEigenValsWithQR(A):
    """
    Returns the eigen values of a matrix A with the QR algorithm.
    """
    k = 20 # modify this line to change the accurency of the eigen values found

    matrixList = []
    matrixList.append(A)

    for i in range (k):
        A_i = Matrix("A_" + str(i), matrixList[i].coeffs.copy())
        Q_i, R_i = A_i.QR_decomposition()     # A_i     = Q_i R_i
        A_i_plus_1 = multiplyMatrix(R_i, Q_i) # A_{i+1} = R_i Q_i
        matrixList.append(A_i_plus_1)

    print("After", k, "iterations :")
    print(matrixList[-1])
    return matrixList[-1]


class Matrix:
    def __init__(self, name, coeffs):
        self.name  = name
        self.coeffs = coeffs


    def nbLines(self):
        """
        Returns the number of lines of the Matrix.
        """
        # Simple array of int : the Matrix is a line matrix.
        if isinstance((self.coeffs)[0], int) or isinstance((self.coeffs)[0], float):
            return 1

        # else : count the number of lines in the array
        nbLines = 0

        for row in self.coeffs:
            nbLines += 1
        return nbLines


    def nbCols(self):
        """
        Returns the number of columns of the Matrix.
        """
        nbCols = 0

        # Line matrix : count the number of coefficients in the line.
        if self.nbLines() == 1:
            for row in self.coeffs:
                nbCols += 1

        # else : count the number of coefficients in the first line.
        else:
            for row in self.coeffs[0]:
                nbCols += 1
        return nbCols


    def isSquare(self):
        """
        Returns a boolean indicating if the Matrix is a square matric or not.
        """
        return self.nbLines() == self.nbCols()


    def getDiag(self):
        """
        Returns the list of the diagonal coefficients of the matrix.
        """
        if not self.isSquare():
            sys.exit("Error : can only extract diagonal from square matrix"\
                     + " (" + self.name + " is a " + str(self.nbCols()) + "*" \
                     + str(self.nbLines()) + " matrix).")

        return [self.getCoeff(i + 1, i + 1) for i in range (self.nbLines())]

    def getCoeff(self, i, j):
        """
        Returns the (i, j) coefficient of the Matrix.
        """
        #error if invalid index
        if (i > self.nbCols() or i < 1) or (j > self.nbLines() or j < 1):
            sys.exit("Error : index ("\
            + str(i) + ", " + str(j)\
            + ") out of range for matrix " + self.name)

        if self.nbLines() == 1:
            return self.coeffs[i - 1]

        return self.coeffs[j - 1][i - 1]


    def getCol(self, colNum):
        """
        Returns the list of coefficients of the column of specified index.
        """
        if colNum < 1 or colNum > self.nbCols() :
            sys.exit("Error : column " + str(colNum)\
            + " doesn't exist for matrix " + self.name)

        colCoeffs = []
        for i in range (self.nbLines()):
            colCoeffs.append(self.getCoeff(colNum, i + 1))
        return colCoeffs


    def multiplyByFactor(self, factor):
        """
        Multiplies all the coefficients of the Matrix by a given factor (which
        must be a number).
        """
        if self.nbLines() == 1:
            for i in range (self.nbCols()):
                self.coeffs[i] *= factor
        else:
            for j in range (self.nbLines()):
                for i in range (self.nbCols()):
                    self.coeffs[j][i] *= factor

    def transposate(self):
        """
        Returns the transposate of the Matrix
        """
        trsp = [[0 for _ in range (self.nbLines())] for _ in range (self.nbCols())]

        for i in range (self.nbLines()):
            for j in range (self.nbCols()):
                trsp[j][i] = self.coeffs[i][j]

        return Matrix(self.name + "^t", trsp)

    def QR_decomposition(self):
        """
        This function returns the QR decomposition of a given matrice (ordered
        pair of Matrix objects (Q, R).
        """
        cols = []
        for i in range (self.nbCols()): # decomposing the matrix into columns
            cols.append(self.getCol(i + 1))

        # finding an orthogonal basis
        uVectors = []

        for i in range (self.nbCols()):
            projectionSum = [0 for _ in range (self.nbLines())]

            # calculating the projection sum
            for j in range (i):
                projectionSum = substractVectors(projectionSum, orthogonalProjection(uVectors[j], cols[i]))
            uVectors.append(addVectors(cols[i], projectionSum))

        U = generateMatrixWithCols("U", uVectors)

        # we can now calculate Q as following :
        qCols = []
        for i in range (self.nbCols()):
            col = Matrix("", uVectors[i].copy())
            col.multiplyByFactor(1/normOf(uVectors[i]))
            qCols.append(col.coeffs)

        Q = generateMatrixWithCols("Q", qCols)

        # calculating R
        Qt = Q.transposate()
        R = multiplyMatrix(Qt, self, "R")

        return Q, R


    def __str__(self):
        """
        Returns a String to be displayed in the shell.
        """
        if self.nbLines() == 1:
            strDisplay = str(self.name)  + " = "\
            + ' '.join(map(str, self.coeffs)).join(("( ", " )"))

        else:
            strDisplay = ""
            blocLen = 0

            for j in range (self.nbLines()):
                tmp = 0
                for i in range (self.nbCols()):
                    tmp += 2 + len(str(self.getCoeff(i + 1, j + 1)))
                blocLen = max([blocLen, tmp])

            margin = len(str(self.name)  + " = ") * " "

            strDisplay += margin + " _" + blocLen * " " + "_\n"
            strDisplay += margin + "|" + (blocLen + 2) * " " + "|\n"

            for lineNo in range (self.nbLines()):
                strDisplay += str(self.name) + " = " if lineNo == self.nbLines()//2\
                                                     else margin

                strDisplay += '  '.join(map(str, self.coeffs[lineNo]))\
                                  .join(("|  ", "  |")) + "\n"
            strDisplay += margin + "|_" + blocLen * " " + "_|\n"

        return strDisplay


### Main program

def main():
    A = Matrix("A", [[0, 2, -1], [3, -2, 0], [-2, 2, 1]])
    print(A)

    A_k = findEigenValsWithQR(A)

    eigenVals = [round(A_k.getDiag()[i], 1) for i in range (A_k.nbLines())]
    print("Eigen values of ", A.name, ":", eigenVals)


    B = Matrix("B", [[3.5, 0, 0], [0, 5.2, 0], [0, 0, 6.9]])
    print(B)

    B_k = findEigenValsWithQR(B)
    eigenVals = [round(B_k.getDiag()[i], 1) for i in range (B_k.nbLines())]
    print("Eigen values of ", B.name, ":", eigenVals)

if __name__ == "__main__":
    main()